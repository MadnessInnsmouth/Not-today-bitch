document.addEventListener('DOMContentLoaded', () => {
    // --- UI Elements ---
    const encryptPasswordInput = document.getElementById('encrypt-password');
    const toggleEncryptPasswordButton = document.getElementById('toggle-encrypt-password');
    const plaintextInput = document.getElementById('plaintext-input');
    const fileEncryptInput = document.getElementById('file-encrypt-input');
    const encryptButton = document.getElementById('encrypt-button');
    const encryptedOutput = document.getElementById('encrypted-output');
    const copyEncryptedButton = document.getElementById('copy-encrypted-button');
    const downloadEncryptedButton = document.getElementById('download-encrypted-button');

    const decryptPasswordInput = document.getElementById('decrypt-password');
    const toggleDecryptPasswordButton = document.getElementById('toggle-decrypt-password');
    const encryptedInput = document.getElementById('encrypted-input');
    const fileDecryptInput = document.getElementById('file-decrypt-input');
    const decryptButton = document.getElementById('decrypt-button');
    const decryptedOutput = document.getElementById('decrypted-output');
    const copyDecryptedButton = document.getElementById('copy-decrypted-button');
    const downloadDecryptedButton = document.getElementById('download-decrypted-button');

    const liveRegion = document.getElementById('live-region');

    // --- Constants ---
    const KEY_ALGO = { name: "AES-GCM", length: 256 };
    const PBKDF2_ALGO = {
        name: "PBKDF2",
        hash: "SHA-256",
        saltLength: 16, // 16 bytes for salt
        iterations: 310000 // Increased iterations for more hellish difficulty / better security!
    };
    const IV_LENGTH = 12; // 96-bit IV
    const AUTH_TAG_LENGTH = 128; // 128-bit authentication tag

    // --- Utility Functions ---

    /**
     * Converts an ArrayBuffer to a Base64 string.
     * @param {ArrayBuffer} buffer The ArrayBuffer to convert.
     * @returns {string} The Base64 encoded string.
     */
    const arrayBufferToBase64 = (buffer) => {
        let binary = '';
        const bytes = new Uint8Array(buffer);
        const len = bytes.byteLength;
        for (let i = 0; i < len; i++) {
            binary += String.fromCharCode(bytes[i]);
        }
        return btoa(binary);
    };

    /**
     * Converts a Base64 string to an ArrayBuffer.
     * @param {string} base64 The Base64 string to convert.
     * @returns {ArrayBuffer} The decoded ArrayBuffer.
     */
    const base64ToArrayBuffer = (base64) => {
        try {
            const binaryString = atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        } catch (e) {
            console.error("Base64 decoding failed:", e);
            throw new Error("Invalid Base64 string provided.");
        }
    };

    /**
     * Displays a message in the live region for screen readers.
     * @param {string} message The message to announce.
     * @param {boolean} isError True if the message is an error, false otherwise.
     */
    const announce = (message, isError = false) => {
        liveRegion.textContent = ''; // Clear previous message immediately
        // Remove existing status classes
        liveRegion.classList.remove('success-message', 'error-message');
        if (isError) {
            liveRegion.classList.add('error-message');
        } else {
            liveRegion.classList.add('success-message');
        }
        liveRegion.textContent = message;
        // Keep message visible/audible for 5 seconds for screen readers
        setTimeout(() => {
            liveRegion.textContent = '';
            liveRegion.classList.remove('success-message', 'error-message');
        }, 5000);
    };

    // --- Key Derivation ---

    /**
     * Derives an AES-GCM key from a password using PBKDF2.
     * @param {string} password The user's password.
     * @param {Uint8Array} salt The salt to use for key derivation.
     * @returns {Promise<CryptoKey>} The derived AES-GCM key.
     */
    const deriveKey = async (password, salt) => {
        const passwordBuffer = new TextEncoder().encode(password);
        const baseKey = await window.crypto.subtle.importKey(
            "raw",
            passwordBuffer,
            { name: PBKDF2_ALGO.name },
            false,
            ["deriveKey"]
        );

        return window.crypto.subtle.deriveKey(
            {
                name: PBKDF2_ALGO.name,
                salt: salt,
                iterations: PBKDF2_ALGO.iterations,
                hash: PBKDF2_ALGO.hash
            },
            baseKey,
            KEY_ALGO,
            false, // not extractable - crucial for security!
            ["encrypt", "decrypt"]
        );
    };

    // --- Encryption Logic ---

    /**
     * Encrypts data using AES-GCM.
     * @param {string | ArrayBuffer} data The data to encrypt (string or ArrayBuffer).
     * @param {string} password The encryption password.
     * @returns {Promise<string>} The Base64 encoded encrypted blob (salt || iv || ciphertext || authTag).
     */
    const encryptData = async (data, password) => {
        try {
            const salt = window.crypto.getRandomValues(new Uint8Array(PBKDF2_ALGO.saltLength));
            const key = await deriveKey(password, salt);

            const iv = window.crypto.getRandomValues(new Uint8Array(IV_LENGTH)); // 96-bit IV, unique per encryption

            let dataBuffer;
            if (typeof data === 'string') {
                dataBuffer = new TextEncoder().encode(data);
            } else if (data instanceof ArrayBuffer) {
                dataBuffer = data;
            } else {
                throw new Error("Invalid data type for encryption. Must be string or ArrayBuffer.");
            }

            const encryptedBuffer = await window.crypto.subtle.encrypt(
                {
                    name: KEY_ALGO.name,
                    iv: iv,
                    tagLength: AUTH_TAG_LENGTH // 128-bit authentication tag
                },
                key,
                dataBuffer
            );

            // Concatenate salt, IV, and the encrypted data (ciphertext + tag).
            const combined = new Uint8Array(salt.length + iv.length + encryptedBuffer.byteLength);
            combined.set(salt, 0);
            combined.set(iv, salt.length);
            combined.set(new Uint8Array(encryptedBuffer), salt.length + iv.length);

            announce("Data encrypted successfully!", false);
            return arrayBufferToBase64(combined.buffer);
        } catch (error) {
            console.error("Encryption failed:", error);
            announce(`Encryption failed: ${error.message}. Ensure your browser supports Web Crypto API.`, true);
            throw error;
        }
    };

    // --- Decryption Logic ---

    /**
     * Decrypts data using AES-GCM.
     * @param {string} encryptedBase64 The Base64 encoded encrypted blob.
     * @param {string} password The decryption password.
     * @returns {Promise<string | ArrayBuffer>} The decrypted data (string or ArrayBuffer).
     */
    const decryptData = async (encryptedBase64, password) => {
        try {
            const encryptedBuffer = base64ToArrayBuffer(encryptedBase64);

            // Ensure the encrypted data is long enough to contain salt, IV, and at least some tag/ciphertext
            // Salt (16) + IV (12) + Auth Tag (16 bytes = 128 bits) = 44 bytes minimum
            if (encryptedBuffer.byteLength < PBKDF2_ALGO.saltLength + IV_LENGTH + (AUTH_TAG_LENGTH / 8)) {
                throw new Error("Encrypted data is too short or malformed. Not a valid encrypted blob.");
            }

            const salt = new Uint8Array(encryptedBuffer.slice(0, PBKDF2_ALGO.saltLength));
            const iv = new Uint8Array(encryptedBuffer.slice(PBKDF2_ALGO.saltLength, PBKDF2_ALGO.saltLength + IV_LENGTH));
            const ciphertextAndTag = encryptedBuffer.slice(PBKDF2_ALGO.saltLength + IV_LENGTH);

            const key = await deriveKey(password, salt);

            const decryptedBuffer = await window.crypto.subtle.decrypt(
                {
                    name: KEY_ALGO.name,
                    iv: iv,
                    tagLength: AUTH_TAG_LENGTH
                },
                key,
                ciphertextAndTag
            );

            announce("Data decrypted successfully!", false);
            return decryptedBuffer; // Return ArrayBuffer for flexibility (text or binary)
        } catch (error) {
            console.error("Decryption failed:", error);
            let userMessage = `Decryption failed: ${error.message}.`;
            if (error.name === "OperationError" && error.message.includes("tag mismatch")) {
                userMessage = "Decryption failed: Incorrect password or corrupted data. Authentication tag mismatch. Ensure your password is exactly correct.";
            } else if (error.name === "DataError") {
                userMessage = "Decryption failed: Data is corrupted or not a valid encrypted blob. It might not be Base64 encoded correctly.";
            } else if (error.name === "InvalidAccessError") { // Covers cases where key usage is wrong or algorithm issues
                userMessage = "Security error: Problem with cryptographic operations. Ensure your browser supports Web Crypto API.";
            } else if (error instanceof Error && error.message.includes("Invalid Base64 string")) {
                userMessage = "Decryption failed: The provided encrypted data is not a valid Base64 string.";
            }
            announce(userMessage + " Please check your password and the encrypted data.", true);
            throw error;
        }
    };

    // --- Event Listeners and UI Interactions ---

    // Toggle password visibility
    const setupPasswordToggle = (inputElement, buttonElement) => {
        let isPasswordVisible = false;
        buttonElement.addEventListener('click', () => {
            if (isPasswordVisible) {
                inputElement.type = 'password';
                buttonElement.textContent = 'Show';
                buttonElement.setAttribute('aria-label', `Show ${inputElement.id.includes('encrypt') ? 'encryption' : 'decryption'} password`);
            } else {
                inputElement.type = 'text';
                buttonElement.textContent = 'Hide';
                buttonElement.setAttribute('aria-label', `Hide ${inputElement.id.includes('encrypt') ? 'encryption' : 'decryption'} password`);
            }
            isPasswordVisible = !isPasswordVisible;
            inputElement.focus(); // Keep focus on the input for accessibility after toggling
        });
    };

    setupPasswordToggle(encryptPasswordInput, toggleEncryptPasswordButton);
    setupPasswordToggle(decryptPasswordInput, toggleDecryptPasswordButton);

    // Main encryption trigger
    encryptButton.addEventListener('click', async () => {
        const password = encryptPasswordInput.value;
        if (!password) {
            announce("Please enter a password for encryption.", true);
            return;
        }

        let dataToEncrypt = null;
        let isFile = false;

        if (plaintextInput.value) {
            dataToEncrypt = plaintextInput.value;
            isFile = false;
        } else if (fileEncryptInput.files.length > 0) {
            const file = fileEncryptInput.files[0];
            isFile = true;
            // Use FileReader to get ArrayBuffer from file
            dataToEncrypt = await new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.onerror = (e) => reject(new Error("Failed to read file for encryption."));
                reader.readAsArrayBuffer(file);
            }).catch(e => {
                announce(e.message, true);
                throw e; // Re-throw to stop further processing
            });
        } else {
            announce("Please enter text or select a file to encrypt.", true);
            return;
        }

        if (dataToEncrypt === null) return; // If file reading failed or no input

        try {
            const encryptedResult = await encryptData(dataToEncrypt, password);
            encryptedOutput.value = encryptedResult;
            plaintextInput.value = ''; // Clear plaintext after encryption
            fileEncryptInput.value = ''; // Clear file input
            encryptedOutput.focus(); // Focus on output for easy copying
        } catch (error) {
            // Error already announced by encryptData
        }
    });

    // Main decryption trigger
    decryptButton.addEventListener('click', async () => {
        const password = decryptPasswordInput.value;
        if (!password) {
            announce("Please enter a password for decryption.", true);
            return;
        }

        let encryptedSourceData = null;
        let originalFileName = 'decrypted_file';
        let originalFileType = 'application/octet-stream';

        if (encryptedInput.value) {
            encryptedSourceData = encryptedInput.value;
        } else if (fileDecryptInput.files.length > 0) {
            const file = fileDecryptInput.files[0];
            originalFileName = file.name;
            originalFileType = file.type || originalFileType;

            encryptedSourceData = await new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(arrayBufferToBase64(e.target.result)); // File content as base64 string
                reader.onerror = (e) => reject(new Error("Failed to read encrypted file for decryption."));
                reader.readAsArrayBuffer(file);
            }).catch(e => {
                announce(e.message, true);
                throw e; // Re-throw to stop further processing
            });
        } else {
            announce("Please paste encrypted data or select an encrypted file to decrypt.", true);
            return;
        }

        if (encryptedSourceData === null) return; // If file reading failed or no input

        try {
            const decryptedBuffer = await decryptData(encryptedSourceData, password);
            processDecryptionResult(decryptedBuffer, originalFileName, originalFileType);
            encryptedInput.value = ''; // Clear encrypted input
            fileDecryptInput.value = ''; // Clear file input
        } catch (error) {
            // Error already announced by decryptData
        }
    });

    /**
     * Processes the decrypted ArrayBuffer, attempting to decode as text, otherwise preparing for binary download.
     * @param {ArrayBuffer} decryptedBuffer The decrypted data as an ArrayBuffer.
     * @param {string} originalFileName Optional: The name of the original encrypted file.
     * @param {string} originalFileType Optional: The MIME type of the original encrypted file.
     */
    const processDecryptionResult = async (decryptedBuffer, originalFileName = 'decrypted_file', originalFileType = 'application/octet-stream') => {
        try {
            // Attempt to decode as text (UTF-8)
            const decodedText = new TextDecoder('utf-8', { fatal: true }).decode(decryptedBuffer);
            decryptedOutput.value = decodedText;
            downloadDecryptedButton.style.display = 'none'; // Hide download button if it's text
            announce("Decrypted successfully as text!", false);
            decryptedOutput.focus();
        } catch (textError) {
            // If TextDecoder fails, it's likely binary or non-UTF8 text
            announce("Decrypted data is binary or not valid UTF-8 text. Click 'Download Decrypted File' to save.", false);
            decryptedOutput.value = `[Binary Data] - Click "Download Decrypted File" to save.`;
            downloadDecryptedButton.style.display = 'inline-block'; // Show download button
            // Set up a *new* click listener to avoid conflicts, or make sure the main one handles this
            downloadDecryptedButton.onclick = () => downloadBlob(decryptedBuffer, `decrypted_${originalFileName}`, originalFileType);
            decryptedOutput.focus();
        }
    };


    // Copy to Clipboard functions
    copyEncryptedButton.addEventListener('click', () => {
        encryptedOutput.select();
        try {
            document.execCommand('copy');
            announce("Encrypted data copied to clipboard!", false);
        } catch (err) {
            console.error('Failed to copy text: ', err);
            announce("Failed to copy encrypted data to clipboard. Please try manually selecting and copying.", true);
        }
    });

    copyDecryptedButton.addEventListener('click', () => {
        decryptedOutput.select();
        try {
            document.execCommand('copy');
            announce("Decrypted data copied to clipboard!", false);
        } catch (err) {
            console.error('Failed to copy text: ', err);
            announce("Failed to copy decrypted data to clipboard. Please try manually selecting and copying.", true);
        }
    });

    // Download functions
    const downloadBlob = (dataBlob, filename, mimeType) => {
        const blob = new Blob([dataBlob], { type: mimeType });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        // Append to body, click, and remove to trigger download
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url); // Clean up the URL object
        announce(`File "${filename}" downloaded.`, false);
    };

    downloadEncryptedButton.addEventListener('click', () => {
        if (encryptedOutput.value) {
            // Encode the Base64 string back to an ArrayBuffer of its UTF-8 representation
            // This ensures consistent file type regardless of content
            downloadBlob(new TextEncoder().encode(encryptedOutput.value), 'encrypted_data.txt', 'text/plain');
        } else {
            announce("No encrypted data to download.", true);
        }
    });

    // The downloadDecryptedButton's onclick is now set entirely within processDecryptionResult
    // so this general listener will only handle cases where processDecryptionResult didn't hide/override it
    // and where it's explicitly text data.
    downloadDecryptedButton.addEventListener('click', (event) => {
        // Only proceed if it's currently text data in the output and no special binary handler is set
        if (decryptedOutput.value && !decryptedOutput.value.includes('[Binary Data]')) {
             downloadBlob(new TextEncoder().encode(decryptedOutput.value), 'decrypted_text.txt', 'text/plain');
        } else if (decryptedOutput.value.includes('[Binary Data]') && typeof event.currentTarget.onclick === 'function') {
            // If it's binary, and a specific onclick was set, let that fire instead of this general one.
            // No action needed here as the direct onclick from processDecryptionResult will be triggered.
        } else {
            announce("No decrypted data to download.", true);
        }
    });


    // Ensure only one input (text or file) is used for encryption/decryption at a time
    plaintextInput.addEventListener('input', () => {
        if (plaintextInput.value) {
            fileEncryptInput.value = ''; // Clear file input if text is entered
        }
    });

    fileEncryptInput.addEventListener('change', () => {
        if (fileEncryptInput.files.length > 0) {
            plaintextInput.value = ''; // Clear text input if file is selected
        }
    });

    encryptedInput.addEventListener('input', () => {
        if (encryptedInput.value) {
            fileDecryptInput.value = ''; // Clear file input if text is entered
        }
    });

    fileDecryptInput.addEventListener('change', () => {
        if (fileDecryptInput.files.length > 0) {
            encryptedInput.value = ''; // Clear text input if file is selected
        }
    });

    // Initial state of download button for decrypted data (hidden by default)
    downloadDecryptedButton.style.display = 'none';

});
