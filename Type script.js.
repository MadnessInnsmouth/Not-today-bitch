document.addEventListener('DOMContentLoaded', () => {
    // --- UI Elements ---
    const encryptPasswordInput = document.getElementById('encrypt-password');
    const toggleEncryptPasswordButton = document.getElementById('toggle-encrypt-password');
    const plaintextInput = document.getElementById('plaintext-input');
    const fileEncryptInput = document.getElementById('file-encrypt-input');
    const encryptButton = document.getElementById('encrypt-button');
    const encryptedOutput = document.getElementById('encrypted-output');
    const copyEncryptedButton = document.getElementById('copy-encrypted-button');
    const downloadEncryptedButton = document.getElementById('download-encrypted-button');

    const decryptPasswordInput = document.getElementById('decrypt-password');
    const toggleDecryptPasswordButton = document.getElementById('toggle-decrypt-password');
    const encryptedInput = document.getElementById('encrypted-input');
    const fileDecryptInput = document.getElementById('file-decrypt-input');
    const decryptButton = document.getElementById('decrypt-button');
    const decryptedOutput = document.getElementById('decrypted-output');
    const copyDecryptedButton = document.getElementById('copy-decrypted-button');
    const downloadDecryptedButton = document.getElementById('download-decrypted-button');

    const liveRegion = document.getElementById('live-region');

    // --- Constants ---
    const KEY_ALGO = { name: "AES-GCM", length: 256 };
    const PBKDF2_ALGO = {
        name: "PBKDF2",
        hash: "SHA-256",
        saltLength: 16, // 16 bytes for salt
        iterations: 310000 // Increased iterations for more hellish difficulty / better security!
    };
    const IV_LENGTH = 12; // 96-bit IV
    const AUTH_TAG_LENGTH = 128; // 128-bit authentication tag

    // --- Utility Functions ---

    /**
     * Converts an ArrayBuffer to a Base64 string.
     * @param {ArrayBuffer} buffer The ArrayBuffer to convert.
     * @returns {string} The Base64 encoded string.
     */
    const arrayBufferToBase64 = (buffer) => {
        let binary = '';
        const bytes = new Uint8Array(buffer);
        const len = bytes.byteLength;
        for (let i = 0; i < len; i++) {
            binary += String.fromCharCode(bytes[i]);
        }
        return btoa(binary);
    };

    /**
     * Converts a Base64 string to an ArrayBuffer.
     * @param {string} base64 The Base64 string to convert.
     * @returns {ArrayBuffer} The decoded ArrayBuffer.
     */
    const base64ToArrayBuffer = (base64) => {
        try {
            const binaryString = atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        } catch (e) {
            console.error("Base64 decoding failed:", e);
            throw new Error("Invalid Base64 string provided.");
        }
    };

    /**
     * Reads a File object as an ArrayBuffer.
     * @param {File} file The File object to read.
     * @returns {Promise<ArrayBuffer>} A promise that resolves with the file content as an ArrayBuffer.
     */
    const readFileAsArrayBuffer = (file) => {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (e) => resolve(e.target.result);
            reader.onerror = (e) => reject(new Error(`Failed to read file: ${file.name}`));
            reader.readAsArrayBuffer(file);
        });
    };

    /**
     * Displays a message in the live region for screen readers.
     * @param {string} message The message to announce.
     * @param {boolean} isError True if the message is an error, false otherwise.
     */
    const announce = (message, isError = false) => {
        // Remove existing status classes for a clean slate
        liveRegion.classList.remove('success-message', 'error-message');

        // Add the appropriate status class for styling (and visual feedback for debug)
        if (isError) {
            liveRegion.classList.add('error-message');
        } else {
            liveRegion.classList.add('success-message');
        }

        // Set the message
        liveRegion.textContent = message;

        // After a delay, clear the text content and remove status classes.
        // The message remains accessible to screen readers for the full duration of the timeout.
        setTimeout(() => {
            liveRegion.textContent = '';
            liveRegion.classList.remove('success-message', 'error-message');
        }, 5000); // Keep message for 5 seconds for screen readers
    };

    // --- Key Derivation ---

    /**
     * Derives an AES-GCM key from a password using PBKDF2.
     * @param {string} password The user's password.
     * @param {Uint8Array} salt The salt to use for key derivation.
     * @returns {Promise<CryptoKey>} The derived AES-GCM key.
     */
    const deriveKey = async (password, salt) => {
        const passwordBuffer = new TextEncoder().encode(password);
        const baseKey = await window.crypto.subtle.importKey(
            "raw",
            passwordBuffer,
            { name: PBKDF2_ALGO.name },
            false,
            ["deriveKey"]
        );

        return window.crypto.subtle.deriveKey(
            {
                name: PBKDF2_ALGO.name,
                salt: salt,
                iterations: PBKDF2_ALGO.iterations,
                hash: PBKDF2_ALGO.hash
            },
            baseKey,
            KEY_ALGO,
            false, // not extractable - crucial for security!
            ["encrypt", "decrypt"]
        );
    };

    // --- Encryption Logic ---

    /**
     * Encrypts data using AES-GCM.
     * @param {string | ArrayBuffer} data The data to encrypt (string or ArrayBuffer).
     * @param {string} password The encryption password.
     * @returns {Promise<string>} The Base64 encoded encrypted blob (salt || iv || ciphertext || authTag).
     */
    const encryptData = async (data, password) => {
        try {
            const salt = window.crypto.getRandomValues(new Uint8Array(PBKDF2_ALGO.saltLength));
            const key = await deriveKey(password, salt);

            const iv = window.crypto.getRandomValues(new Uint8Array(IV_LENGTH)); // 96-bit IV, unique per encryption

            let dataBuffer;
            if (typeof data === 'string') {
                dataBuffer = new TextEncoder().encode(data);
            } else if (data instanceof ArrayBuffer) {
                dataBuffer = data;
            } else {
                throw new Error("Invalid data type for encryption. Must be string or ArrayBuffer.");
            }

            const encryptedBuffer = await window.crypto.subtle.encrypt(
                {
                    name: KEY_ALGO.name,
                    iv: iv,
                    tagLength: AUTH_TAG_LENGTH // 128-bit authentication tag
                },
                key,
                dataBuffer
            );

            // Concatenate salt, IV, and the encrypted data (ciphertext + tag).
            const combined = new Uint8Array(salt.length + iv.length + encryptedBuffer.byteLength);
            combined.set(salt, 0);
            combined.set(iv, salt.length);
            combined.set(new Uint8Array(encryptedBuffer), salt.length + iv.length);

            announce("Data encrypted successfully!", false);
            return arrayBufferToBase64(combined.buffer);
        } catch (error) {
            console.error("Encryption failed:", error);
            announce(`Encryption failed: ${error.message}. Ensure your browser supports Web Crypto API.`, true);
            throw error;
        }
    };

    // --- Decryption Logic ---

    /**
     * Decrypts data using AES-GCM.
     * @param {string} encryptedBase64 The Base64 encoded encrypted blob.
     * @param {string} password The decryption password.
     * @returns {Promise<string | ArrayBuffer>} The decrypted data (string or ArrayBuffer).
     */
    const decryptData = async (encryptedBase64, password) => {
        try {
            const encryptedBuffer = base64ToArrayBuffer(encryptedBase64);

            // Ensure the encrypted data is long enough to contain salt, IV, and at least some tag/ciphertext
            // Salt (16) + IV (12) + Auth Tag (16 bytes = 128 bits) = 44 bytes minimum
            if (encryptedBuffer.byteLength < PBKDF2_ALGO.saltLength + IV_LENGTH + (AUTH_TAG_LENGTH / 8)) {
                throw new Error("Encrypted data is too short or malformed. Not a valid encrypted blob.");
            }

            const salt = new Uint8Array(encryptedBuffer.slice(0, PBKDF2_ALGO.saltLength));
            const iv = new Uint8Array(encryptedBuffer.slice(PBKDF2_ALGO.saltLength, PBKDF2_ALGO.saltLength + IV_LENGTH));
            const ciphertextAndTag = encryptedBuffer.slice(PBKDF2_ALGO.saltLength + IV_LENGTH);

            const key = await deriveKey(password, salt);

            const decryptedBuffer = await window.crypto.subtle.decrypt(
                {
                    name: KEY_ALGO.name,
                    iv: iv,
                    tagLength: AUTH_TAG_LENGTH
                },
                key,
                ciphertextAndTag
            );

            announce("Data decrypted successfully!", false);
            return decryptedBuffer; // Return ArrayBuffer for flexibility (text or binary)
        } catch (error) {
            console.error("Decryption failed:", error);
            let userMessage = `Decryption failed: ${error.message}.`;
            if (error.name === "OperationError" && error.message.includes("tag mismatch")) {
                userMessage = "Decryption failed: Incorrect password or corrupted data. Authentication tag mismatch. Ensure your password is exactly correct.";
            } else if (error.name === "DataError") {
                userMessage = "Decryption failed: Data is corrupted or not a valid encrypted blob. It might not be Base64 encoded correctly.";
            } else if (error.name === "InvalidAccessError") { // Covers cases where key usage is wrong or algorithm issues
                userMessage = "Security error: Problem with cryptographic operations. Ensure your browser supports Web Crypto API.";
            } else if (error instanceof Error && error.message.includes("Invalid Base64 string")) {
                userMessage = "Decryption failed: The provided encrypted data is not a valid Base64 string.";
            }
            announce(userMessage + " Please check your password and the encrypted data.", true);
            throw error;
        }
    };

    // --- Event Listeners and UI Interactions ---

    // Toggle password visibility
    const setupPasswordToggle = (inputElement, buttonElement) => {
        let isPasswordVisible = false;
        buttonElement.addEventListener('click', () => {
            if (isPasswordVisible) {
                inputElement.type = 'password';
                buttonElement.textContent = 'Show';
                buttonElement.setAttribute('aria-label', `Show ${inputElement.id.includes('encrypt') ? 'encryption' : 'decryption'} password`);
            } else {
                inputElement.type = 'text';
                buttonElement.textContent = 'Hide';
                buttonElement.setAttribute('aria-label', `Hide ${inputElement.id.includes('encrypt') ? 'encryption' : 'decryption'} password`);
            }
            isPasswordVisible = !isPasswordVisible;
            inputElement.focus(); // Keep focus on the input for accessibility after toggling
        });
    };

    setupPasswordToggle(encryptPasswordInput, toggleEncryptPasswordButton);
    setupPasswordToggle(decryptPasswordInput, toggleDecryptPasswordButton);

    // Main encryption trigger
    encryptButton.addEventListener('click', async () => {
        const password = encryptPasswordInput.value;
        if (!password) {
            announce("Please enter a password for encryption.", true);
            return;
        }

        let dataToEncrypt = null;

        try {
            if (plaintextInput.value) {
                dataToEncrypt = plaintextInput.value;
            } else if (fileEncryptInput.files.length > 0) {
                const file = fileEncryptInput.files[0];
                dataToEncrypt = await readFileAsArrayBuffer(file); // Await file reading
            } else {
                announce("Please enter text or select a file to encrypt.", true);
                return;
            }

            const encryptedResult = await encryptData(dataToEncrypt, password);
            encryptedOutput.value = encryptedResult;
            plaintextInput.value = ''; // Clear plaintext after encryption
            fileEncryptInput.value = ''; // Clear file input
            encryptedOutput.focus(); // Focus on output for easy copying
        } catch (error) {
            // Error already announced by encryptData or readFileAsArrayBuffer
            console.error("Encryption process failed:", error); // Log for debugging
        }
    });

    // Main decryption trigger
    decryptButton.addEventListener('click', async () => {
        const password = decryptPasswordInput.value;
        if (!password) {
            announce("Please enter a password for decryption.", true);
            return;
        }

        let encryptedSourceData = null;
        let originalFileName = 'decrypted_file'; // Default for text or unknown file type
        let originalFileType = 'application/octet-stream';

        try {
            if (encryptedInput.value) {
                encryptedSourceData = encryptedInput.value;
            } else if (fileDecryptInput.files.length > 0) {
                const file = fileDecryptInput.files[0];
                originalFileName = file.name;
                originalFileType = file.type || originalFileType;
                const fileBuffer = await readFileAsArrayBuffer(file); // Await file reading
                encryptedSourceData = arrayBufferToBase64(fileBuffer); // Convert file content to base64 string
            } else {
                announce("Please paste encrypted data or select an encrypted file to decrypt.", true);
                return;
            }

            const decryptedBuffer = await decryptData(encryptedSourceData, password);
            processDecryptionResult(decryptedBuffer, originalFileName, originalFileType);
            encryptedInput.value = ''; // Clear encrypted input
            fileDecryptInput.value = ''; // Clear file input
        } catch (error) {
            // Error already announced by decryptData or readFileAsArrayBuffer
            console.error("Decryption process failed:", error); // Log for debugging
        }
    });

    /**
     * Processes the decrypted ArrayBuffer, attempting to decode as text, otherwise preparing for binary download.
     * @param {ArrayBuffer} decryptedBuffer The decrypted data as an ArrayBuffer.
     * @param {string} originalFileName Optional: The name of the original encrypted file.
     * @param {string} originalFileType Optional: The MIME type of the original encrypted file.
     */
    const processDecryptionResult = async (decryptedBuffer, originalFileName = 'decrypted_file', originalFileType = 'application/octet-stream') => {
        // Hide the download button initially for new decryption attempts
        downloadDecryptedButton.style.display = 'none';
        downloadDecryptedButton.onclick = null; // Clear previous dynamic click handler

        try {
            // Attempt to decode as text (UTF-8)
            const decodedText = new TextDecoder('utf-8', { fatal: true }).decode(decryptedBuffer);
            decryptedOutput.value = decodedText;
            announce("Decrypted successfully as text!", false);
            decryptedOutput.focus();
        } catch (textError) {
            // If TextDecoder fails, it's likely binary or non-UTF8 text
            announce("Decrypted data is binary or not valid UTF-8 text. Click 'Download Decrypted File' to save.", false);
            decryptedOutput.value = `[Binary Data] - Click "Download Decrypted File" to save.`;
            downloadDecryptedButton.style.display = 'inline-block'; // Show download button
            // Set the dynamic download action for binary data
            downloadDecryptedButton.onclick = () => downloadBlob(decryptedBuffer, `decrypted_${originalFileName}`, originalFileType);
            decryptedOutput.focus();
        }
    };


    // Copy to Clipboard functions
    copyEncryptedButton.addEventListener('click', () => {
        if (encryptedOutput.value) {
            encryptedOutput.select();
            try {
                document.execCommand('copy');
                announce("Encrypted data copied to clipboard!", false);
            } catch (err) {
                console.error('Failed to copy text: ', err);
                announce("Failed to copy encrypted data to clipboard. Please try manually selecting and copying.", true);
            }
        } else {
            announce("No encrypted data to copy.", true);
        }
    });

    copyDecryptedButton.addEventListener('click', () => {
        if (decryptedOutput.value && !decryptedOutput.value.includes('[Binary Data]')) { // Only copy if it's actual text
            decryptedOutput.select();
            try {
                document.execCommand('copy');
                announce("Decrypted data copied to clipboard!", false);
            } catch (err) {
                console.error('Failed to copy text: ', err);
                announce("Failed to copy decrypted data to clipboard. Please try manually selecting and copying.", true);
            }
        } else if (decryptedOutput.value.includes('[Binary Data]')) {
             announce("Cannot copy binary data to clipboard. Please use the download button.", true);
        } else {
             announce("No decrypted data to copy.", true);
        }
    });


    // Download functions
    const downloadBlob = (dataBlob, filename, mimeType) => {
        const blob = new Blob([dataBlob], { type: mimeType });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        // Append to body, click, and remove to trigger download
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url); // Clean up the URL object
        announce(`File "${filename}" downloaded.`, false);
    };

    downloadEncryptedButton.addEventListener('click', () => {
        if (encryptedOutput.value) {
            // Download the Base64 string as a text file
            downloadBlob(new TextEncoder().encode(encryptedOutput.value), 'encrypted_data.txt', 'text/plain');
        } else {
            announce("No encrypted data to download.", true);
        }
    });

    // The downloadDecryptedButton's onclick is now managed exclusively by processDecryptionResult for binary data,
    // and this general listener handles only text data by default.
    downloadDecryptedButton.addEventListener('click', (event) => {
        // If an inline onclick handler for binary data is set, let that handle the click
        if (typeof event.currentTarget.onclick === 'function' && event.currentTarget.onclick !== null) {
            // If the element has an inline 'onclick' set (e.g., from processDecryptionResult for binary data),
            // prevent this generic listener from interfering. The specific handler will execute.
            return;
        }

        // Otherwise, if there's decrypted text, download it as a text file
        if (decryptedOutput.value && !decryptedOutput.value.includes('[Binary Data]')) {
             downloadBlob(new TextEncoder().encode(decryptedOutput.value), 'decrypted_text.txt', 'text/plain');
        } else {
            announce("No decrypted data to download or it's binary and requires its specific download action.", true);
        }
    });


    // Ensure only one input (text or file) is used for encryption/decryption at a time
    // This UX is crucial to prevent ambiguity
    plaintextInput.addEventListener('input', () => {
        if (plaintextInput.value) {
            fileEncryptInput.value = ''; // Clear file input if text is entered
        }
    });

    fileEncryptInput.addEventListener('change', () => {
        if (fileEncryptInput.files.length > 0) {
            plaintextInput.value = ''; // Clear text input if file is selected
        }
    });

    encryptedInput.addEventListener('input', () => {
        if (encryptedInput.value) {
            fileDecryptInput.value = ''; // Clear file input if text is entered
        }
    });

    fileDecryptInput.addEventListener('change', () => {
        if (fileDecryptInput.files.length > 0) {
            encryptedInput.value = ''; // Clear text input if file is selected
        }
    });

    // Initial state of download button for decrypted data (hidden by default)
    downloadDecryptedButton.style.display = 'none';

    // Check for Web Crypto API support on load
    if (!window.crypto || !window.crypto.subtle) {
        announce("Your browser does NOT support the Web Crypto API. This tool will not function. Please use a modern browser (Safari, Chrome, Firefox, Edge).", true);
        encryptButton.disabled = true;
        decryptButton.disabled = true;
    }
});
